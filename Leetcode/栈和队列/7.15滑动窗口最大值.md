# 滑动窗口最大值

这道题目就像一个笑话说的那样
1.队尾的老员工没有新员工那么能干 被淘汰
2.队首的老员工已经掉出浪潮中了 淘汰
3.在队首的永远是胜者

由此得到这道题目的思路，维护一个双端单调队列，只需要对应笑话的三点就行了：
1.队尾的数字小于等于当前下标i的数字 压出并且压入当前下标到队尾
2.队首的数字下标小于left(滑动窗口的开头) 压出
3.当滑动窗口形成的时候 left>=0 队列里面的就是满足的答案了

值得注意的是，这道题目我们操作的对象是下标i，而非实际的元素，这样子逻辑就会简单很多

写出以下代码：
```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        //这道题目关键在于维护双端队列的单调性
        //如果队列里面的队尾小于等于当前的元素 那么就需要弹出 之后压入该元素
        //如果队首离开了视野 那也需要弹出
        //如果滑动窗口形成了 那么就把队首压入答案中
        //我们操作的是下标 而非元素
        vector<int> ans;
        deque<int> deq;
        for(int i{0};i<nums.size();i++){
            //维护单调队列
            while((deq.empty()==false) && (nums[deq.back()] <= nums[i])){
                deq.pop_back();
            }
            deq.push_back(i);
            //判断是否离开了视野
            int left{i - k + 1};
            //记住left 变量表示当前滑动窗口的左端点位置
            if(deq.front() < left){
                deq.pop_front();
            }
            if(left >= 0){//当left>=0的时候滑动窗口才形成
                int ans_num = deq.front();
                ans.push_back(nums[ans_num]);
            }
        }
        return ans;
    }
};
```