# 数组中的第K个最大元素

学会了 快速排序这个算法 快排就是递归

快速排序（Quick Sort）是一种高效的排序算法，基于分治法（Divide and Conquer）的思想。它的核心是通过选择一个基准元素（pivot），将列表分为两部分：一部分小于基准元素，另一部分大于基准元素，然后递归地对这两部分进行排序。快速排序的平均时间复杂度为 O(n log n)，在实际应用中性能优异。

初始化左指针 left（指向数组起始）和右指针 right（指向数组末尾）。
右指针左移，找到第一个小于基准值的元素，停下。
左指针右移，找到第一个大于基准值的元素，停下。
交换左右指针指向的元素。
重复步骤 2-4，直到左指针超过右指针。
最后将基准值与左指针指向的元素交换，完成分区。



```cpp
class Solution {
public:
    int quicksort(vector<int>& nums,int left, int right) {
        // 快速排序+选择递归 = 快速选择 
        int base = nums[left];
        while(left < right) {
            while(left < right && nums[right] >= base) {
                right--;
            }
            nums[left] = nums[right]; // 右指针左移，找到第一个小于基准值的元素，停下。
            while(left < right && nums[left] <= base) {
                left++;
            }
            nums[right] = nums[left]; 左指针右移，找到第一个大于基准值的元素，停下。
        }
        nums[left] = base; 交换左右指针指向的元素。
        return left;
    }
    void traversal(vector<int>& nums,int left, int right, int k) {
        if(left < right) {
            int base = quicksort(nums,left,right);
            if(base == k) return ;
            else if(base < k) traversal(nums,base + 1, right, k);
            else traversal(nums,left,base - 1, k);
        }
    }
    int findKthLargest(vector<int>& nums, int k) {
        // 使用快排做一下
        traversal(nums, 0, nums.size() - 1, nums.size() - k);
        return nums[nums.size() - k];
    }
};

```