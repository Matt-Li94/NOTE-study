# 买卖股票的能获得的最大金额系列
买卖股票的套路是定义一个二维dp数组 其中

dp[i][0] 表示到第i天不持有股票得到的最大利润
dp[i][1] 表示到第i天持有股票得到的最大利润

然后更新的递推公式就简单了
```cpp

dp[i][0] 不持有股票 dp[i - 1][0] 和 dp[i][1] + prices[i]取最大
dp[i][1] 持有股票 dp[i - 1][1] 和 dp[i][0] - prices[i]取最大

注意上面是可以多次买卖所以是dp[i][0] - prices[i] -> 买卖股票的最佳时机Ⅱ
如果是只能买卖一次就是 0 - prices[i] 因为就只有这一天买入 前面都没有买入的 -> 买卖股票的最佳时机Ⅰ

如果是包含冷冻期 但是也可以多次买入卖出 那就是下面这个递推公式 -> 买卖股票的最佳时机含冷冻期

dp[i][0] 表示 第i天不持有股票的最大利润 那么它等于 dp[i - 1][0] 和 dp[i - 1][1] + prices[i] 取最大
dp[i][1] 表示 第i天持有股票的最大利润 等于 dp[i - 1][1] 和 dp[i - 2][0] - prices[i] 取最大


下面给出包含冷冻期的代码
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // dp[i][0] 表示 第i天不持有股票的最大利润 那么它等于 dp[i - 1][0] 和 dp[i - 1][1] + prices[i]
        // dp[i][1] 等于 dp[i - 1][1] 和 dp[i - 2][0] - prices[i]
        if(prices.size() == 1) return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        dp[1][0] = max(0, prices[1] - prices[0]);
        dp[1][1] = max(-prices[1],  dp[0][1]); // 注意dp[1][1]的初始化 你之前错过的
        for(int i{2};i<prices.size();i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 2][0] - prices[i]);
        }
        return max(dp[prices.size() - 1][0], dp[prices.size() - 1][1]); 
    }
};

```