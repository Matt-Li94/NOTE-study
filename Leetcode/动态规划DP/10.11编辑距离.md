# 编辑距离
这道题目是比较难的 

相较其他题目 这道题目在初始化的时候就需要用上递推公式了

思路是 如果下标i和j相等的时候 那就是 dp[i][j] = dp[i - 1][j - 1];
如果不相等 那么可以有三种修改方案 

1.删除word1的单词 那么就是 dp[i - 1][j] + 1
2.删除word2的单词 那么就是 dp[i][j - 1] + 1
3.替换使之相同 那么就是dp[i - 1][j - 1] + 1

有三种修改方案 我们只需要取最小的方案就可以了

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        // 使用代码随想录的思路 对于字符串的还是有点难得
        // 这种字符串最好还是使用拼接与否得思路
        // dp[i][j] 表示i下标结束和j下标结束的最少操作数 那么dp[0][j] 那就是一直要添加字符了
        if(word1 == "" && word2 == "") return 0;
        else if(word2 == "") return word1.size();
        else if(word1 == "") return word2.size();
        vector<vector<int>> dp(word1.size(), vector<int>(word2.size(), 0));
        if(word1[0] == word2[0]) dp[0][0] = 0;
        else if(word1[0] != word2[0]) dp[0][0] = 1;
        for(int i{1};i<word1.size();i++) {
            // 初始化 如果不相等的话就用上递推公式
            if(word1[i] == word2[0]) dp[i][0] = i;
            else dp[i][0] = dp[i - 1][0] + 1;
        }
        for(int j{1};j<word2.size();j++) {
            if(word2[j] == word1[0]) dp[0][j] = j;
            else dp[0][j] = dp[0][j - 1] + 1;
        }
        for(int i{1};i<word1.size();i++) {
            for(int j{1};j<word2.size();j++) {
                if(word1[i] == word2[j]) dp[i][j] = dp[i - 1][j - 1];
                else dp[i][j] = min(dp[i - 1][j] + 1, min(dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1));
            }
        }
        return dp[word1.size() - 1][word2.size() - 1];
    }
};
```