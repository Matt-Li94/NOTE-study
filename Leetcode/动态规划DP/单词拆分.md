# 这个真的是做了好久

第一次采用一维数组
1.dp[j]表示长度为j的字符串能不能被worddict填充满

2.dp[j] = dp[j] || dp[j - length] 这个是递推公式 dp[j]来自于两部分 一部分是长度为length的字符串，另一部分是长为j-length的字符串。
那么如果length的长度是匹配的 那么就看剩下的j-length的字符串是不是匹配的 所以这里dp[j] = dp[j] || dp[j - length]表示为 dp[j]
等于当前可拆分的 或 剩下的长度是否可以拆分 如果剩下的可以 那就是都可以 如果剩下的不行 那就都不行。

也可以这么理解 若相等，说明从 [i - sz] 到 i 的字符与 word 匹配。
那么dp[j] = dp[j] || dp[j - length]; 这里的第一个dp[j] 表示当前未更新的dp[j] 第二个dp[j] 表示之前的数值 这个是需要动态理解的 不能当成一样



```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        // 使用一维数组dp[j] 表示字符长度为j的 字符串能不能被worddict填充满
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        unordered_set<string> set(wordDict.begin(), wordDict.end());
        // 先遍历背包 在遍历物品 因为求排列数 而且完全背包 内层是正序遍历
        for(int j{0};j<s.size() + 1;j++) {
            for(int i{0};i<wordDict.size();i++) {
                if(j < wordDict[i].size()) continue;
                // 没有就继续跑 知道找到够长度的
                else {
                    int length = wordDict[i].size();
                    string ss = s.substr(j - length, length);
                    if(set.find(ss) != set.end()) dp[j] = dp[j] || dp[j - length];
                    else continue;
                    // 不匹配就继续往后走 不是像数值动态题目一样每一个都要更新dp的
                }
            }
        }
        return dp[s.size()];
    }
};
```