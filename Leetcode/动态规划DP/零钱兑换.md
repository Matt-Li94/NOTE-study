# 要求组成金额的最小硬币数量
这个是完全背包问题 这个要处理的细节真的太tm多了 太难了
有一些笔记在纸质那里记着
代码如下：
```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        // 二维 dp dp[i][j]表示从0-i几个下标中凑出面额为j的最小硬币个数
        // dp[0][j]表示 凑成j的最小 j%coins[0] == 0 那么就是 j/coins[0]个 不然就是0
        // dp[i][0] 等于0 凑成0的最少个数就是0
        // dp[0][j] 只有当j能整除coins[0]的时候才可以有解 不然就不变
        // 使用INT_MAX表示没有解 
        vector<vector<int>> dp(coins.size(), vector<int>(amount + 1, INT_MAX));
        for(int j{0};j<amount + 1;j++) {
            if(j < coins[0]) dp[0][j] = INT_MAX;
            if(j % coins[0] == 0) dp[0][j] = j / coins[0];
            else continue;
        }
        for(int i{0};i<coins.size();i++) {
            dp[i][0] = 0;
        }
        for(int i{1};i<coins.size();i++) {
            for(int j{0};j<amount + 1;j++) {
                if(j < coins[i]) dp[i][j] = dp[i - 1][j];
                else if (j>= coins[i] && dp[i][j - coins[i]] != INT_MAX) {
                    // 只有j>= coins[i] 且子问题有解的时候才能加 不然就不能使用这个下标的硬币i 
                    dp[i][j] = min(dp[i - 1][j], dp[i][j - coins[i]] + 1);
                    // 这里+1是表示硬币数量 应为是要使用这个硬币的 所以+1 这里够你喝一壶了
                }
                else if(j>= coins[i] && dp[i][j - coins[i]] == INT_MAX) dp[i][j] = dp[i - 1][j];
            }
        }
        if(dp[coins.size() - 1][amount] == INT_MAX) return -1;
        else return dp[coins.size() - 1][amount];
    }
};
```