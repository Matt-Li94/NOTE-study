# N皇后 
这个题目起始就是标准的回溯模板 
只不过检测条件那边变得复杂了 要检测 列 左上 右上 一定要仔细去写
而且要收集row == n 的解 这个时候说明皇后全部排好了

代码如下
```cpp
class Solution {
private:
    vector<string> chessboard;
    vector<vector<string>> result;
public:
    // 回溯的一个经典例子
    // n就是树的深度和广度
    // 这个相当于是多个集合 每次是从不同的集合开始 所以for的起始都是列的开始
    // 每次搜索都是从每一行的第一列开始搜索到最后一列 找到满足条件的位置防止皇后
    bool isVaild(int row, int col, int n) {
        //检查当前行的所有列
        for(int i{0};i<row;i++) {
            if(chessboard[i][col] == 'Q') { 
                return false;
            }
        }
        //检查左上
        for(int i{row - 1},j{col - 1};i>=0 && j>=0;i--,j--) {
            if(chessboard[i][j] == 'Q') {
                return false;
            }
        }
        //检查右上
        for(int i{row - 1},j{col + 1};i >=0 && j < n;i--,j++) {
            if(chessboard[i][j] == 'Q') {
                return false;
            }
        }
        return true;
    }
    void backtracking(int n, int row) {
        if(row == n) {
            result.push_back(chessboard);
            return ;
        }
        for(int j{0}; j<n; j++) {
            // 每次从每一行的第一列开始搜索
            if(isVaild(row, j, n) == true) {
                chessboard[row][j] = 'Q';
                backtracking(n, row + 1);
                chessboard[row][j] = '.';
            }
        }
    }
    vector<vector<string>> solveNQueens(int n) {
        chessboard = vector<string>{static_cast<size_t>(n), string(n, '.')};
        /* 这里不能写成下面的代码 因为chessboard的类成员 直接赋值可以 但是下面是重新初始化一个chessboard变量 这是不行的
            vector<string>chessboard{static_cast<size_t>(n), string(n, '.')};
        */
        backtracking(n,0);
        return result;
    }
};
```