# 复原ip地址
这道题目和分割回文子串一样是经典的分割题目

这道题目回溯的时候容易出错

依旧是子只有满足判断的时候才进入递归

为什么要限制pointnum == 4 呢 因为不限制的话会出现到达了最后但是点很多的答案

```cpp
class Solution {
    string path;
    vector<string> result; 
public:
    bool IsUseIp(string ss) {
        // 有效子ip 长度小于等于3 大于等于1 且大于1的时候第一个不能是0 数字位于0-255
        int length = ss.size();
        if(length > 3 || length < 1) return false;
        int num = stoi(ss);
        if(num > 255 || num < 0) return false;
        if(length > 1 && ss[0] == '0') return false;
        return true;
    }
    void backtracking(string s, int startindex, int pointnum) {
        if(startindex == s.size() && pointnum == 4) {
            // 一定要限制点 == 4
            result.push_back(path);
            return ;
        }
        for(int i{startindex}; i<s.size(); i++) {
            string ss = s.substr(startindex, i - startindex + 1);
            if(IsUseIp(ss) == true) {
                int len = 0;
                if(pointnum == 3) {
                    path = path + ss;
                    len = ss.size();
                    pointnum++;
                }
                else{
                    path = path + ss + '.';
                    len = ss.size() + 1;
                    pointnum++;
                }
                backtracking(s,i + 1,pointnum);
                while(len--) {
                    path.pop_back();
                }
                // 一定要注意减点数 pointnum也要回溯
                pointnum--;
            }
        }
    }
    vector<string> restoreIpAddresses(string s) {
        backtracking(s,0,0);
        return result;
    }
};
```
