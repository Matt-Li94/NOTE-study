# 组合
这是第一道回溯算法
给定一个n 和 k 需要找到 k 个数字的组合 其中这些组合需要在 [1 , n]
回溯的本质是递归 和树一样的递归方式
回溯的模板如下：一个for循环和递归。for循环负责横向遍历，递归负责纵向遍历。
```cpp
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        // 一般这个for循环的起始是自己定义的startindex
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```
这道题目不难写出代码如下
```cpp
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    void backtracking(int n, int k, int startindex) {
        // 终止条件
        if(path.size() == k) {
            result.push_back(path);
            return;
        }
        // for 循环
        for(int i = startindex; i <= n ; i++) {
            path.push_back(i); // 处理节点
            backtracking(n, k , i + 1);
            path.pop_back(); // 回溯
        }
    }
    vector<vector<int>> combine(int n, int k) {
        backtracking(n, k, 1);
        return result;

    }
};
```