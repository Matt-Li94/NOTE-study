# 获取子集

这道题目和之前的回溯模板是一样的 

只不过之前是收集叶子节点的结果

现在是收集所有节点就行了 

代码如下：

```cpp
class Solution {
private:
    vector<int> path;
    vector<vector<int>> result;
public:
    //用回溯模板写一遍 这道题目就是收集所有节点
    void backtracking(vector<int>& nums, int startindex) {
        if(path.size() > nums.size()) return ; //当长度大于自己的时候就是到叶子了 需要返回
        if(path.size() <= nums.size()) {
            // 注意注意 ！！ 收集结果不能return 需要它继续往下走的 所以不能return
            result.push_back(path);
        }
        for(int i{startindex}; i<nums.size(); i++) {
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }
    vector<vector<int>> subsets(vector<int>& nums) {
        backtracking(nums,0);
        return result;
    }
};
```


下面这个是去重的一个题解

去重逻辑是树层去重 在数层的时候 如果当前和上一个是一样的就跳过 记住要先排序nums和i > startindex

```cpp
class Solution {
private:
    vector<int> path;
    vector<vector<int>> result;
public:
    void backtracking(vector<int>& nums, int startindex) {
        if(path.size() > nums.size()) return;
        if(path.size() <= nums.size()) {
            result.push_back(path);
        }
        for(int i{startindex}; i < nums.size(); i++) {
            if(i > startindex && nums[i] == nums[i - 1]) continue;
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        backtracking(nums,0);
        return result;
    }
};
```