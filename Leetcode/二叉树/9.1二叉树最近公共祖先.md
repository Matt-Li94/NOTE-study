# 二叉树的最近公共祖先
竟然隔了快一个月没有刷题了 看来还是低估了论文的潜在工作量了 还有就是自己搞完这些之后的松弛感了
这道题目是给定两个节点 寻找最近他们公共祖先 最好的就是父节点了 但是不排除其中一个是另外一个的子节点或者父节点 
这样子也是满足的
这道题目使用回溯法自底向上遍历，所以使用后序遍历 
代码如下：
```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // 直接返回判断值 如果当前节点的左右孩子返回值都不为空 那么当前节点就是祖先节点
        // 直接判断当前节点是否存在等于p和q的 如果存在就返回它
        // 使用后续遍历完成回溯的过程
        if(root == nullptr || root == q || root == p) {
            return root;
        } //寻找节点相同的过程 如果有返回值 那么就是说明左/右孩子是满足条件的
        TreeNode* left = lowestCommonAncestor(root->left,p,q);
        TreeNode* right = lowestCommonAncestor(root->right,p,q);
        // 对于节点返回值的判断过程
        if(left != nullptr && right == nullptr) {
            return left;
        }
        else if(left == nullptr && right != nullptr) {
            return right;
        }
        else if(left != nullptr && right != nullptr) {
            return root;
        }
        else {
            return nullptr;
        }
    }
};

```