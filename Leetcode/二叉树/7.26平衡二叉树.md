# 平衡二叉树
这道题目的思路就是复用之前获取二叉树深度的思路了
在每一个节点获取当前节点的左右孩子的深度，并且对其进行判断
如果左右孩子的深度差超过1那么就返回false
当然也可以使用一个变量来进行剪枝 如果高度差大于一那么我们使这个变量为-1 那么就可以根据这个变量的值来进行判断结果了
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int traversal(TreeNode *root){
        if(root == nullptr) return 0;
        int left_height = traversal(root->left);
        int right_height = traversal(root->right);
        if(left_height == -1 || right_height == -1 || abs(left_height - right_height) > 1) {
            return -1;
        }
        int height = max(left_height,right_height) + 1;
        return height;
    }
    bool isBalanced(TreeNode* root) {
        // 使用后序遍历 同时使用一个标记变量获取状态 如果不平衡了就返回false
        // 对于一个节点 他的高度是左右孩子的最大高度
        int result = traversal(root);
        if(result == -1){
            return false;
        }
        return true;
    }
};
```