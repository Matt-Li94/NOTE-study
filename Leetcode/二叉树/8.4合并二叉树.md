# 合并二叉树
感觉自己有点蠢呀 对一些细节没有想明白
思路简单但是代码一些起来细节很差 自己阅读代码理解
```cpp
class Solution {
public:
    void traversal(TreeNode*& root1, TreeNode* root2) {//注意这里传的是引用 会修改外部root1， root2值传递不动它
        if(root1 == nullptr && root2 == nullptr) return;
        if(root1 == nullptr && root2 != nullptr) {
            root1 = new TreeNode(root2->val);
            //这里直接在原地new就行了 
            //如果你写TreeNode* root1 = new TreeNode(root2->val);那就是创建了一个新的同名指针变量root1了 你想的明白嘛春竹
        }
        else if(root1 != nullptr && root2 == nullptr) {
            root1->val = root1->val;
        }
        else if(root1 !=nullptr && root2 != nullptr) {
            root1->val = root1->val + root2->val;
        }
        traversal(root1->left, root2 ? root2->left : nullptr);
        // 这里为什么要对root2进行判断 因为不能出现空指针解引用 即不能出现nullptr->left 
        // if(root->left != nullptr) traversal(root->left,targetSum,sum,target); 你都知道这么写 到后面就懵圈了？
        traversal(root1->right, root2 ? root2->right : nullptr);
    }
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        traversal(root1,root2);
        return root1;
    }
};
```