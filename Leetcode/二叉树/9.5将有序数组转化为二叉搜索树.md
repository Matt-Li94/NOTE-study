# 依旧从数组生成树
二叉搜索树要求左小右大 
那么一个有序数组从中间划分就是最合适的 中间作为根节点就行了
值得注意的一个点就是 也是你错误的地方
取中间的数字的数组索引直接就是长度的一半
切记不用分奇偶情况讨论 因为偶数的情况就是两个取一个就行（这么算就是后面那个）
奇数的情况就是int类型直接舍掉了小数点 加上数组索引从0开始的性质 那么就刚好落在了中间位置
```cpp
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        // 按照数组中间划分左右子树
        if(nums.empty() == true) return nullptr; //递归一定要记得终止条件啊啊啊啊啊啊
        int length = nums.size();
        int left_length = length / 2;
        vector<int> left_nums(nums.begin(), nums.begin() + left_length);
        vector<int> right_nums(nums.begin() + left_length + 1, nums.end());
        TreeNode* right = sortedArrayToBST(right_nums);
        TreeNode* left = sortedArrayToBST(left_nums);
        TreeNode* root = new TreeNode(nums[left_length],left,right);
        return root;
    }
};
```