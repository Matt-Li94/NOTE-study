# 对称和相同的树
这两道题目直接使用相同的思路就行了 自底向上
灵神的代码简洁的不敢形象
```cpp
/*对称的树*/
class Solution {
public:
    bool trval(TreeNode* right,TreeNode* left){
        if((right == nullptr) || (left == nullptr)){
            return right == left;
        }
        return right->val == left->val && trval(right->right,left->left) && trval(right->left,left->right);
    }
    bool isSymmetric(TreeNode* root) {
        //使用递归去解决 这道题目灵神的解法简洁的不敢想象
        return trval(root->right,root->left);
    }
};
/*相同的树*/
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if((p == nullptr) || (q == nullptr)){
            return p == q;
        }
        // 如果存在一个空节点 那么就需要全部两个都是空节点才可以
        return q->val == p->val && isSameTree(p->right,q->right) && isSameTree(p->left , q->left);
        // 排除了空节点的情况就进行递归判断
    }
};
/*另一棵树的子树*/
class Solution {
public:
    bool isSametree(TreeNode* q, TreeNode* p) {
        if(q == nullptr || p == nullptr) {
            return q == p;
        }
        return q->val == p->val && isSametree(q->left,p->left) && isSametree(q->right,p->right);
    }
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        // 暴力匹配做法 对root的每一个节点进行相同的树的判断逻辑
        if(root == nullptr) return false;
        return isSametree(root,subRoot) || isSubtree(root->left,subRoot) || isSubtree(root->right,subRoot);
    }
};
```