# 左叶子之和 
依旧是层序遍历 只不过需要不用vector
左不空左左右右空 左叶子
```cpp
class Solution {
public:
    //复用层序遍历思路 只不过多了一个左叶子的判断逻辑 且不要vector
    int sumOfLeftLeaves(TreeNode* root) {
        if(root == nullptr) return 0;
        queue<TreeNode*> que;
        que.push(root);
        int sum{0};
        while(que.empty() == false) {
            int length = que.size();
            for(int i{0};i<length;i++){
                TreeNode* node = que.front();
                que.pop();
                if(node->left != nullptr) que.push(node->left);
                if(node->right != nullptr) que.push(node->right);
                if(node->left != nullptr && node->left->left == nullptr && node->left->right == nullptr) {
                    // 左叶子的判断逻辑 有点冗余 通过父节点去判断左叶子 左不空左左右右空 左叶子
                    sum = sum + node->left->val;
                }
            }
        }
        return sum;
    }
};
```