# 路径总和
一样的思路 使用两个变量一个是标志位 找到了就设为1
另外一个是和 如果和等于目标和 那么就可以设置标志位了
根据标志位来判断是否成功
值得注意的是回溯 应该你使用了全局变量sum 那么就要有回溯减掉节点值的操作 如果你使用的是值传递那么就不需要回溯了
不难写出以下代码
```cpp
class Solution {
public:
    //标志位和sum两个变量
    void traversal(TreeNode* root, int targetSum, int& sum, int& target) {
        if(root == nullptr) return;
        sum = sum + root->val;
        if(sum == targetSum && root->left == nullptr && root->right == nullptr) target = 1;
        if(root->left != nullptr) traversal(root->left,targetSum,sum,target);
        if(root->right != nullptr) traversal(root->right,targetSum,sum,target);
        sum = sum - root->val;
    }
    bool hasPathSum(TreeNode* root, int targetSum) {
        int sum = 0;
        int target = 0;
        traversal(root,targetSum,sum,target);
        return target == 1;
    }
};
```