# 两种递归思路
这道题目的思路是使用一个int当前深度和int最大深度去记录
在单层递归里面当前深度++ 并且更新最大深度
最后返回最大深度
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //自底向上的递归思路 找到最后的在进行单层递归操作
    int maxDepth(TreeNode* root) {
        //二叉树的题目还是使用递归来解决 使用递归的时候不要太过纠结于整个过程 只需要想明白怎么运动的就行了
        if(root == nullptr) return 0;
        int left_depth = maxDepth(root->left);
        int right_depth = maxDepth(root->right);
        return max(left_depth,right_depth) + 1;
    }
    //自顶向下的递归思想 单层递归操作要在递归之前执行
    //自顶向下是使用辅助函数收集外界的变量结果并且记录
    // 然而自底向上是直接return这个结果的给外界变量
    void traverse(TreeNode* root, int current_depth, int& max_depth) {
    if (root == nullptr) return;
    // 在“递”的过程中计算当前节点的深度
    current_depth++; 
    // 更新全局最大深度
    if (current_depth > max_depth) {
        max_depth = current_depth;
    }
    // 继续递归处理子树
    traverse(root->left, current_depth, max_depth);
    traverse(root->right, current_depth, max_depth);
}

    int maxDepth(TreeNode* root) {
        int max_depth = 0;
        traverse(root, 0, max_depth);
        return max_depth;
    }
};
```