# 找众数
中序遍历+哈希表+桶排序秒了
```cpp
class Solution {
public:
    void traversal(TreeNode* root, vector<int>& nums) {
        if(root == nullptr) return ;
        traversal(root->left,nums);
        nums.push_back(root->val);
        traversal(root->right,nums);
    }
    vector<int> findMode(TreeNode* root) {
        //这道题目就是找数组中最大频率的数
        //哈希表和中序遍历秒了
        vector<int> nums;
        traversal(root,nums);
        unordered_map<int,int> umap;
        for(const int& i : nums) {
            umap[i]++;//元素 频率
        }
        // 需要找到最大频率才可以 桶的大小只能是最大频率+1 不能是umap的大小
        int max_fre{-999999999};
        for(auto it = umap.begin();it != umap.end(); it++) {
            max_fre = max(it->second,max_fre);
        }

        vector<vector<int>> bucket{static_cast<size_t>(max_fre) + 1};
        for(auto it = umap.begin();it != umap.end(); it++) {
            bucket[it->second].push_back(it->first);
        }
        vector<int> result;
        result.insert(result.end(),bucket[max_fre].begin(),bucket[max_fre].end());
        return result;
    }
};
```
但是没有必要创建这里的两个桶 因为再容量设置的时候比较容易出错
因为只需要一个频率就行了 那么就可以找最大频率 然后回去再遍历哈希表 输出元素就行了
```cpp
class Solution {
public:
    void traversal(TreeNode* root, vector<int>& nums) {
        if(root == nullptr) return ;
        traversal(root->left, nums);
        nums.push_back(root->val);
        traversal(root->right, nums);
    }
    
    vector<int> findMode(TreeNode* root) {
        vector<int> nums;
        traversal(root, nums); // 中序遍历获取有序数组
        
        unordered_map<int, int> umap;
        for(const int& i : nums) {
            umap[i]++; // 统计每个元素的频率
        }
        
        // 找到最大频率
        int maxFreq = 0;
        for(auto& pair : umap) {
            maxFreq = max(maxFreq, pair.second);
        }
        
        // 收集所有具有最大频率的元素
        vector<int> result;
        for(auto& pair : umap) {
            if(pair.second == maxFreq) {
                result.push_back(pair.first);
            }
        }
        
        return result;
    }
};
```