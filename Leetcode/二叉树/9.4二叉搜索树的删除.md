# 二叉搜索树的删除
删除两部曲 delete删除内存+指针置为空

这里只是要分情况讨论

最后一种比较复杂的情况是左右孩子都不为空

那么需要把左子树放到右子树的最左端位置 然后删除root 之后把右子树放到root的位置就可以了 

代码如下：
```cpp
class Solution {
public:
    void traversal(TreeNode* &root, int key) {
        if(root == nullptr) return;
        if(root->val == key) {
            // 查到了 分情况讨论
            if(root->left == nullptr && root->right == nullptr) {
                delete root;
                root = nullptr; //删除之后记得置为空 避免野指针
                return;
            }
            else if(root->left != nullptr && root->right == nullptr) {
                TreeNode* left_node  = root->left;
                delete root;
                root = left_node;
                return;
            }
            else if(root->left == nullptr && root->right != nullptr) {
                TreeNode* right_node = root->right;
                delete root;
                root = right_node;
                return;
            }
            else if(root->left != nullptr && root->right != nullptr) {
                TreeNode* right_node = root->right;
                TreeNode* left_node = root->left;
                TreeNode* tmp_node = right_node;
                while(tmp_node->left != nullptr) {
                    tmp_node = tmp_node->left;
                }
                delete root;
                root = right_node;
                tmp_node -> left = left_node;
                return;
            }
        }
        if(root->val > key) traversal(root->left,key);
        if(root->val < key) traversal(root->right,key);
    }
    TreeNode* deleteNode(TreeNode* root, int key) {
        // 这道题目不难 就是删除的情况有点多
        // 对应有无左右孩子 无 有左 有右 有左右
        // 寻找的逻辑是大于往右 小于往右
        traversal(root,key);
        return root;
    }
};

```