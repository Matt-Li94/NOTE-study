# 修剪二叉搜索树
这道题目是比较抽象的 令我难以理解
并没有显式delete操作 而是使用了重定向的方法 这是ai和我解释的 
总而言之 背答案吧
```cpp
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        // 模板化答案 很懵圈的一道题目
        // 我说白了我白说了我不太懂
        if(root == nullptr) return nullptr;
        if(root->val < low) {
            //情况1：当前值都小于左边界 直接舍弃 然后去右边找
            TreeNode* right = trimBST(root->right,low,high);
            return right;
        }
        else if(root->val > high) {
            //情况2：当前值都大于右边界 直接舍弃 然后去左边找
            TreeNode* left = trimBST(root->left,low,high);
            return left;
        }
        else {
            //情况3：当前的值满足条件 继续递归检查他的左右子树
            root->left = trimBST(root->left,low,high);
            root->right = trimBST(root->right,low,high);
        }
        return root;
    }
};
```