# 重构二叉树
熟悉一下中序和后序遍历的思路 那么后序遍历的最后一个就是根节点了 那么在中序遍历中 根节点左边就是左子树 右边就是右子树
那么问题就变成了从这个两个数组中构造出中后序的左右子树数组了
问题进一步划分就合理了
定义四个数组 分别装左右子树 注意是左闭右开
子问题就是让左右子树自己去递归构造 最后返回根节点并且连接左右子树
```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        // 关键是构造左右子树的一个数组 
        // 从后序遍历可以找到根节点 
        if(postorder.empty() == true) return nullptr;
        int left_length = static_cast<int>(ranges::find(inorder,postorder.back()) - inorder.begin()); //左子树的长度
        vector<int> in_left_node(inorder.begin(), inorder.begin() + left_length);
        vector<int> in_right_node(inorder.begin() + left_length + 1, inorder.end());
        vector<int> pos_left_node(postorder.begin(),postorder.begin() + left_length);
        vector<int> pos_right_node(postorder.begin() + left_length, postorder.end() - 1);
        TreeNode* left_tree = buildTree(in_left_node, pos_left_node);
        TreeNode* right_tree = buildTree(in_right_node, pos_right_node);
        TreeNode* tree_node = new TreeNode(postorder.back(),left_tree,right_tree);
        return tree_node;
    }
};
```